{"cells":[{"metadata":{"trusted":true},"cell_type":"code","source":"#Q(2)(a)\n\n#Import the necessary library\nimport numpy as np\n\n#Define the function to be integrated from the statement\ndef f(x):\n    return 1/((1+x)**2)\n\n#Define the trapezoid rule function\ndef trapezoid_rule(a, b, n, func):\n    h = (b - a) / n #Calculate the step size\n    x = np.linspace(a, b, n + 1) #Generate equally spaced points from a to b\n    y = func(x) #Evaluate the function at these points\n    return h * (np.sum(y) - 1/2 * (y[0] + y[-1])) #Calculate the trapezoidal sum\n\n#Define the limits of integration\na = 0\nb = 2\n\nexact_integral = 2/3  #The exact integral of 1/((1+x)^2) from 0 to 2 is 2/3\n\n#Initialize the variable to store the previous error\nerror_prev = None \n\n#Test the trapezoid rule function with different numbers of subdivisions\nfor N in [20, 40, 80]:\n    approx_integral = trapezoid_rule(a, b, N, f) #Calculate the approximate integral using the trapezoid rule\n    error = abs(exact_integral - approx_integral) #Calculate the absolute error between the exact and approximate integral\n    print(f\"If h = {2/N}, the error is {error}\") #Print the step size and the corresponding error\n    \n    #If a previous error exists, calculate and print the ratio of successive errors\n    if error_prev is not None:\n        ratio = error_prev / error\n        print(f\"The ratio of successive errors is {ratio}\")\n        \n    error_prev = error #Update the previous error\n","execution_count":2,"outputs":[{"output_type":"stream","text":"If h = 0.1, the error is 0.001601642128346903\nIf h = 0.05, the error is 0.00040102746246584164\nThe ratio of successive errors is 3.9938465024283123\nIf h = 0.025, the error is 0.00010029568053082638\nThe ratio of successive errors is 3.9984519806172893\n","name":"stdout"}]},{"metadata":{"trusted":true},"cell_type":"code","source":"##From the output above, we can observe that as the step size h decreases by a factor of 2 (from 0.1 to 0.05, and from 0.05 to 0.025), \n#the error approximately decreases by a factor of 4. This is a characteristic of second order convergence.","execution_count":5,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"#Q(2)(b)\n\n#Define the function to be integrated from the statement\ndef f(x):\n    return np.sqrt(x)\n\n#Define the limits of integration\na = 0\nb = 1\n\nexact_integral = 2/3  #The exact integral of sqrt(x) from 0 to 1 is 2/3\n\n#Initialize the variable to store the previous error\nerror_prev = None\n\n#Test the trapezoid rule function with different numbers of subdivisions\nfor N in [16, 32, 64, 128]:\n    approx_integral = trapezoid_rule(a, b, N, f) #Calculate the approximate integral using the trapezoid rule\n    error = abs(exact_integral - approx_integral) #Calculate the absolute error between the exact and approximate integral\n    print(f\"If h = {N}, the error is {error}\") #Print the step size and the corresponding error\n    \n    #If a previous error exists, calculate and print the ratio of successive errors\n    if error_prev is not None:\n        ratio = error_prev / error\n        print(f\"The ratio of successive errors is {ratio}\")\n        \n    error_prev = error #Update the previous error\n","execution_count":7,"outputs":[{"output_type":"stream","text":"If h = 16, the error is 0.0030854697894384664\nIf h = 32, the error is 0.0011077303877248257\nThe ratio of successive errors is 2.785397804041227\nIf h = 64, the error is 0.0003958552881596633\nThe ratio of successive errors is 2.798321560575026\nIf h = 128, the error is 0.00014100936984062784\nThe ratio of successive errors is 2.8072977604755516\n","name":"stdout"}]},{"metadata":{"trusted":true},"cell_type":"code","source":"##From the output above, we can observe that as the number of intervals N doubles (from 16 to 32, 32 to 64, and 64 to 128),\n#the error approximately reduces to a quarter of its previous value. This is an indication of second order convergence.\n#While these ratios are not exactly 4, they do indicate that the error is decreasing roughly in line with the square \n#of the increase in N, which suggests second order convergence.","execution_count":8,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"#Q(3)(a)\n\n#Define the function to be integrated from the statement\ndef f(x):\n    return np.cos(x**2)\n\n#Define the trapezoid rule function\ndef trapezoid_rule(a, b, n, func):\n    h = (b - a) / n #Calculate the step size\n    x = np.linspace(a, b, n + 1) #Generate equally spaced points from a to b\n    y = func(x) #Evaluate the function at these points\n    return h * (np.sum(y) - 1/2 * (y[0] + y[-1]))    #Calculate the trapezoidal sum\n\n#Define the function to find a suitable h and calculate the error\ndef find_h_and_error(func, a, b, target_q, h_start):\n    h = h_initial #Start with the initial h\n    #Keep looping until the desired accuracy is achieved\n    while True:\n        #Calculate the trapezoidal sum for h, h/2, and h/4\n        T_h = trapezoid_rule(a, b, int((b - a) / h), func)\n        T_h_half = trapezoid_rule(a, b, int((b - a) / (h / 2)), func)\n        T_h_quarter = trapezoid_rule(a, b, int((b - a) / (h / 4)), func)\n        \n        #Calculate q(h)\n        q_h = (T_h_half - T_h) / (T_h_quarter - T_h_half)\n        #If q(h) is close enough to the target value, break the loop\n        if np.isclose(q_h, target_q, rtol=1e-2):\n            break\n            \n        h /= 2  #Otherwise, halve h for the next iteration\n    \n    #Calculate the error\n    error = abs(T_h_half - T_h)\n    return h, error, T_h, T_h_half\n\n#Define the limits of integration\na = 0\nb = np.sqrt(np.pi / 2)\n\n#Define the initial h and the target q\nh_initial = 0.1\ntarget_q = 4\n\n#Call the function to find h and calculate the error\nh, error, T_h, T_h_half = find_h_and_error(f, a, b, target_q, h_initial)\n\n#Print the result\nprint(f\"The value of h for which q(h) is approximately 4 is {h}\")","execution_count":11,"outputs":[{"output_type":"stream","text":"The value of h for which q(h) is approximately 4 is 0.05\n","name":"stdout"}]},{"metadata":{"trusted":true},"cell_type":"code","source":"#Q(3)(b)\n\n#Print the result by using output and function in (a)\nprint(f\"The approximation of the error is {error}\")","execution_count":12,"outputs":[{"output_type":"stream","text":"The approximation of the error is 0.00039386975721300566\n","name":"stdout"}]},{"metadata":{"trusted":true},"cell_type":"code","source":"#Q(3)(c)\n\n#Calculate the improved approximation\nS_h = T_h + 4/3 * (T_h_half - T_h)\n\n#Print the result\nprint(f\"The improved approximation is {S_h}\")\n","execution_count":13,"outputs":[{"output_type":"stream","text":"The improved approximation is 0.9774514588255858\n","name":"stdout"}]},{"metadata":{"trusted":true},"cell_type":"code","source":"#Q(3)(d)\n\n#The reason why S_h[cos(x**2)] is more accurate and convergent faster is that S_h[cos(x**2)] includes an error correction term.\n#And, by adding By adding this error correction term to T_h[cos(x**2)], we effectively reduce the error in the approximation.","execution_count":15,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"#Q(4)\n\n#Define the function to be integrated from the statement\ndef f(x):\n    return 1 / (1 + np.sin(x)**2)\n\n#Define the trapezoid rule function\ndef trapezoid_rule(a, b, n, func):\n    h = (b - a) / n #Calculate the step size\n    x = np.linspace(a, b, n + 1) #Generate equally spaced points from a to b\n    y = func(x) #Evaluate the function at these points\n    return h * (np.sum(y) - 1/2 * (y[0] + y[-1])) #Calculate the trapezoidal sum\n\n#Define the limits of integration\na = 0\nb = 2*np.pi\n\n#Define the exact value of the integral\nexact_value_integral = np.sqrt(2*np.pi)\n\n#Test the trapezoid rule function with different numbers of subdivisions\nfor N in [10, 20, 40, 80, 160, 320]: \n    h = (b - a) / N #Calculate the step size\n    approx_integral = trapezoid_rule(a, b, N, f) #Calculate the approximate integral using the trapezoid rule\n    error = abs(exact_value_integral - approx_integral) #Calculate the absolute error between the exact and approximate integral\n    \n    #print the result\n    print(f\"If h = {h:.10f}, T_h = {approx_integral:.10f}, Error = {error:.10f}\")\n","execution_count":5,"outputs":[{"output_type":"stream","text":"For h = 0.6283185307, T_h = 4.4442042417, Error = 1.9375759670\nFor h = 0.3141592654, T_h = 4.4428831346, Error = 1.9362548599\nFor h = 0.1570796327, T_h = 4.4428829382, Error = 1.9362546635\nFor h = 0.0785398163, T_h = 4.4428829382, Error = 1.9362546635\nFor h = 0.0392699082, T_h = 4.4428829382, Error = 1.9362546635\nFor h = 0.0196349541, T_h = 4.4428829382, Error = 1.9362546635\n","name":"stdout"}]},{"metadata":{"trusted":true},"cell_type":"code","source":"##From h=0.6283185307 to h = 0.1570796327, we can see that as h decreaes, the error decreases too.This suggests that the approximation is converging to the exact solution, \n#which is what we expect for a numerical integration method like the trapezoidal rule.\n#However, after h=0.1570796327, we can see that as h decreaes, the error holds at Error = 1.9362546635, which suggests that the method has reached \n#its limit of precision for this particular function and interval","execution_count":null,"outputs":[]}],"metadata":{"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"language_info":{"name":"python","version":"3.6.15","mimetype":"text/x-python","codemirror_mode":{"name":"ipython","version":3},"pygments_lexer":"ipython3","nbconvert_exporter":"python","file_extension":".py"}},"nbformat":4,"nbformat_minor":5}